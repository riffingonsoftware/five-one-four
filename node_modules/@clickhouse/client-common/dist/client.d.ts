import type { BaseClickHouseClientConfigOptions, ClickHouseSettings, ConnExecResult, IsSame, WithClickHouseSummary } from '@clickhouse/client-common';
import { type DataFormat } from '@clickhouse/client-common';
import type { InputJSON, InputJSONObjectEachRow } from './clickhouse_types';
import type { ImplementationDetails } from './config';
import type { ConnPingResult } from './connection';
import type { BaseResultSet } from './result';
export interface BaseQueryParams {
    /** ClickHouse's settings that can be applied on query level. */
    clickhouse_settings?: ClickHouseSettings;
    /** Parameters for query binding. https://clickhouse.com/docs/en/interfaces/http/#cli-queries-with-parameters */
    query_params?: Record<string, unknown>;
    /** AbortSignal instance to cancel a request in progress. */
    abort_signal?: AbortSignal;
    /** A specific `query_id` that will be sent with this request.
     *  If it is not set, a random identifier will be generated automatically by the client. */
    query_id?: string;
    /** A specific ClickHouse Session id for this query.
     *  If it is not set, {@link BaseClickHouseClientConfigOptions.session_id} will be used.
     *  @default undefined (no override) */
    session_id?: string;
    /** When defined, overrides the credentials from the {@link BaseClickHouseClientConfigOptions.username}
     *  and {@link BaseClickHouseClientConfigOptions.password} settings for this particular request.
     *  @default undefined (no override) */
    auth?: {
        username: string;
        password: string;
    };
}
export interface QueryParams extends BaseQueryParams {
    /** Statement to execute. */
    query: string;
    /** Format of the resulting dataset. */
    format?: DataFormat;
}
/** Same parameters as {@link QueryParams}, but with `format` field as a type */
export type QueryParamsWithFormat<Format extends DataFormat> = Omit<QueryParams, 'format'> & {
    format?: Format;
};
/** If the Format is not a literal type, fall back to the default behavior of the ResultSet,
 *  allowing to call all methods with all data shapes variants,
 *  and avoiding generated types that include all possible DataFormat literal values. */
export type QueryResult<Stream, Format extends DataFormat> = IsSame<Format, DataFormat> extends true ? BaseResultSet<Stream, unknown> : BaseResultSet<Stream, Format>;
export interface ExecParams extends BaseQueryParams {
    /** Statement to execute. */
    query: string;
}
export type CommandParams = ExecParams;
export type CommandResult = {
    query_id: string;
} & WithClickHouseSummary;
export type InsertResult = {
    /**
     * Indicates whether the INSERT statement was executed on the server.
     * Will be `false` if there was no data to insert.
     * For example: if {@link InsertParams.values} was an empty array,
     * the client does not send any requests to the server, and {@link executed} is false.
     */
    executed: boolean;
    /**
     * Empty string if {@link executed} is false.
     * Otherwise, either {@link InsertParams.query_id} if it was set, or the id that was generated by the client.
     */
    query_id: string;
} & WithClickHouseSummary;
export type ExecResult<Stream> = ConnExecResult<Stream>;
export type PingResult = ConnPingResult;
export type InsertValues<Stream, T = unknown> = ReadonlyArray<T> | Stream | InputJSON<T> | InputJSONObjectEachRow<T>;
type NonEmptyArray<T> = [T, ...T[]];
/** {@link except} field contains a non-empty list of columns to exclude when generating `(* EXCEPT (...))` clause */
export interface InsertColumnsExcept {
    except: NonEmptyArray<string>;
}
export interface InsertParams<Stream = unknown, T = unknown> extends BaseQueryParams {
    /** Name of a table to insert into. */
    table: string;
    /** A dataset to insert. */
    values: InsertValues<Stream, T>;
    /** Format of the dataset to insert. Default: `JSONCompactEachRow` */
    format?: DataFormat;
    /**
     * Allows to specify which columns the data will be inserted into.
     * Accepts either an array of strings (column names) or an object of {@link InsertColumnsExcept} type.
     * Examples of generated queries:
     *
     * - An array such as `['a', 'b']` will generate: `INSERT INTO table (a, b) FORMAT DataFormat`
     * - An object such as `{ except: ['a', 'b'] }` will generate: `INSERT INTO table (* EXCEPT (a, b)) FORMAT DataFormat`
     *
     * By default, the data is inserted into all columns of the {@link InsertParams.table},
     * and the generated statement will be: `INSERT INTO table FORMAT DataFormat`.
     *
     * See also: https://clickhouse.com/docs/en/sql-reference/statements/insert-into */
    columns?: NonEmptyArray<string> | InsertColumnsExcept;
}
export declare class ClickHouseClient<Stream = unknown> {
    private readonly clientClickHouseSettings;
    private readonly connectionParams;
    private readonly connection;
    private readonly makeResultSet;
    private readonly valuesEncoder;
    private readonly sessionId?;
    private readonly logWriter;
    constructor(config: BaseClickHouseClientConfigOptions & ImplementationDetails<Stream>);
    /**
     * Used for most statements that can have a response, such as SELECT.
     * FORMAT clause should be specified separately via {@link QueryParams.format} (default is JSON)
     * Consider using {@link ClickHouseClient.insert} for data insertion,
     * or {@link ClickHouseClient.command} for DDLs.
     * Returns an implementation of {@link BaseResultSet}.
     */
    query<Format extends DataFormat = 'JSON'>(params: QueryParamsWithFormat<Format>): Promise<QueryResult<Stream, Format>>;
    /**
     * It should be used for statements that do not have any output,
     * when the format clause is not applicable, or when you are not interested in the response at all.
     * Response stream is destroyed immediately as we do not expect useful information there.
     * Examples of such statements are DDLs or custom inserts.
     * If you are interested in the response data, consider using {@link ClickHouseClient.exec}
     */
    command(params: CommandParams): Promise<CommandResult>;
    /**
     * Similar to {@link ClickHouseClient.command}, but for the cases where the output is expected,
     * but format clause is not applicable. The caller of this method is expected to consume the stream,
     * otherwise, the request will eventually be timed out.
     */
    exec(params: ExecParams): Promise<ExecResult<Stream>>;
    /**
     * The primary method for data insertion. It is recommended to avoid arrays in case of large inserts
     * to reduce application memory consumption and consider streaming for most of such use cases.
     * As the insert operation does not provide any output, the response stream is immediately destroyed.
     * In case of a custom insert operation, such as, for example, INSERT FROM SELECT,
     * consider using {@link ClickHouseClient.command}, passing the entire raw query there (including FORMAT clause).
     */
    insert<T>(params: InsertParams<Stream, T>): Promise<InsertResult>;
    /**
     * Health-check request. It does not throw if an error occurs -
     * the error is returned inside the result object.
     */
    ping(): Promise<PingResult>;
    /**
     * Shuts down the underlying connection.
     * This method should ideally be called only once per application lifecycle,
     * for example, during the graceful shutdown phase.
     */
    close(): Promise<void>;
    private withClientQueryParams;
}
export {};
