"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebConnection = void 0;
const client_common_1 = require("@clickhouse/client-common");
const utils_1 = require("../utils");
class WebConnection {
    constructor(params) {
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: params
        });
        Object.defineProperty(this, "defaultHeaders", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.defaultHeaders = {
            Authorization: `Basic ${btoa(`${params.username}:${params.password}`)}`,
            ...params?.http_headers,
        };
    }
    async query(params) {
        const query_id = getQueryId(params.query_id);
        const clickhouse_settings = (0, client_common_1.withHttpSettings)(params.clickhouse_settings, this.params.compression.decompress_response);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            query_id,
        });
        const response = await this.request({
            values: params.query,
            params,
            searchParams,
        });
        return {
            query_id,
            stream: response.body || new ReadableStream(),
        };
    }
    async exec(params) {
        const result = await this.runExec(params);
        return {
            query_id: result.query_id,
            stream: result.stream || new ReadableStream(),
        };
    }
    async command(params) {
        const { stream, query_id } = await this.runExec(params);
        if (stream !== null) {
            await stream.cancel();
        }
        return { query_id };
    }
    async insert(params) {
        const query_id = getQueryId(params.query_id);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            query: params.query,
            session_id: params.session_id,
            query_id,
        });
        const res = await this.request({
            values: params.values,
            params,
            searchParams,
        });
        if (res.body !== null) {
            await res.text(); // drain the response (it's empty anyway)
        }
        return {
            query_id,
        };
    }
    async ping() {
        // ClickHouse /ping endpoint does not support CORS,
        // so we are using a simple SELECT as a workaround
        try {
            const response = await this.request({
                values: 'SELECT 1 FORMAT CSV',
            });
            if (response.body !== null) {
                await response.body.cancel();
            }
            return { success: true };
        }
        catch (error) {
            if (error instanceof Error) {
                return {
                    success: false,
                    error,
                };
            }
            throw error; // should never happen
        }
    }
    async close() {
        return;
    }
    async request({ values, params, searchParams, pathname, method, }) {
        const url = (0, client_common_1.transformUrl)({
            url: this.params.url,
            pathname,
            searchParams,
        }).toString();
        const abortController = new AbortController();
        let isTimedOut = false;
        const timeout = setTimeout(() => {
            isTimedOut = true;
            abortController.abort();
        }, this.params.request_timeout);
        let isAborted = false;
        if (params?.abort_signal !== undefined) {
            params.abort_signal.onabort = () => {
                isAborted = true;
                abortController.abort();
            };
        }
        try {
            const headers = (0, client_common_1.withCompressionHeaders)({
                headers: params?.auth !== undefined
                    ? {
                        ...this.defaultHeaders,
                        Authorization: `Basic ${btoa(`${params.auth.username}:${params.auth.password}`)}`,
                    }
                    : this.defaultHeaders,
                compress_request: false,
                decompress_response: this.params.compression.decompress_response,
            });
            const response = await fetch(url, {
                body: values,
                headers,
                keepalive: this.params.keep_alive.enabled,
                method: method ?? 'POST',
                signal: abortController.signal,
            });
            clearTimeout(timeout);
            if ((0, client_common_1.isSuccessfulResponse)(response.status)) {
                return response;
            }
            else {
                return Promise.reject((0, client_common_1.parseError)(await (0, utils_1.getAsText)(response.body || new ReadableStream())));
            }
        }
        catch (err) {
            clearTimeout(timeout);
            if (isAborted) {
                return Promise.reject(new Error('The user aborted a request.'));
            }
            if (isTimedOut) {
                return Promise.reject(new Error('Timeout error.'));
            }
            if (err instanceof Error) {
                // maybe it's a ClickHouse error
                return Promise.reject((0, client_common_1.parseError)(err));
            }
            // shouldn't happen
            throw err;
        }
    }
    async runExec(params) {
        const query_id = getQueryId(params.query_id);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            query_id,
        });
        const response = await this.request({
            values: params.query,
            params,
            searchParams,
        });
        return {
            stream: response.body,
            query_id,
        };
    }
}
exports.WebConnection = WebConnection;
function getQueryId(query_id) {
    return query_id || crypto.randomUUID();
}
//# sourceMappingURL=web_connection.js.map