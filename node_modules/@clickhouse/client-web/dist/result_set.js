"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResultSet = void 0;
const client_common_1 = require("@clickhouse/client-common");
const client_common_2 = require("@clickhouse/client-common");
const utils_1 = require("./utils");
class ResultSet {
    constructor(_stream, format, query_id) {
        Object.defineProperty(this, "_stream", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _stream
        });
        Object.defineProperty(this, "format", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: format
        });
        Object.defineProperty(this, "query_id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: query_id
        });
        Object.defineProperty(this, "isAlreadyConsumed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    /** See {@link BaseResultSet.text} */
    async text() {
        this.markAsConsumed();
        return (0, utils_1.getAsText)(this._stream);
    }
    /** See {@link BaseResultSet.json} */
    async json() {
        // JSONEachRow, etc.
        if ((0, client_common_1.isStreamableJSONFamily)(this.format)) {
            const result = [];
            const reader = this.stream().getReader();
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    break;
                }
                for (const row of value) {
                    result.push(row.json());
                }
            }
            return result;
        }
        // JSON, JSONObjectEachRow, etc.
        if ((0, client_common_1.isNotStreamableJSONFamily)(this.format)) {
            const text = await (0, utils_1.getAsText)(this._stream);
            return JSON.parse(text);
        }
        // should not be called for CSV, etc.
        throw new Error(`Cannot decode ${this.format} as JSON`);
    }
    /** See {@link BaseResultSet.stream} */
    stream() {
        this.markAsConsumed();
        (0, client_common_2.validateStreamFormat)(this.format);
        let decodedChunk = '';
        const decoder = new TextDecoder('utf-8');
        const transform = new TransformStream({
            start() {
                //
            },
            transform: (chunk, controller) => {
                if (chunk === null) {
                    controller.terminate();
                }
                decodedChunk += decoder.decode(chunk);
                const rows = [];
                // eslint-disable-next-line no-constant-condition
                while (true) {
                    const idx = decodedChunk.indexOf('\n');
                    if (idx !== -1) {
                        const text = decodedChunk.slice(0, idx);
                        decodedChunk = decodedChunk.slice(idx + 1);
                        rows.push({
                            text,
                            json() {
                                return JSON.parse(text);
                            },
                        });
                    }
                    else {
                        if (rows.length) {
                            controller.enqueue(rows);
                        }
                        break;
                    }
                }
            },
            flush() {
                decodedChunk = '';
            },
        });
        const pipeline = this._stream.pipeThrough(transform, {
            preventClose: false,
            preventAbort: false,
            preventCancel: false,
        });
        return pipeline;
    }
    async close() {
        this.markAsConsumed();
        await this._stream.cancel();
    }
    markAsConsumed() {
        if (this.isAlreadyConsumed) {
            throw new Error(streamAlreadyConsumedMessage);
        }
        this.isAlreadyConsumed = true;
    }
}
exports.ResultSet = ResultSet;
const streamAlreadyConsumedMessage = 'Stream has been already consumed';
//# sourceMappingURL=result_set.js.map