import * as _clickhouse_client_web from '@clickhouse/client-web';
import { ClickHouseClient } from '@clickhouse/client-web';

declare const mapToClickHouseType: (value: Value) => string;
declare const getValueFromParameter: (value: any) => any;
declare function createClickhouseParameter(parameterIndex: number, value: Value): string;
/**
 * Values supported by SQL engine.
 */
type Value = string | number | boolean | Date | [string, string];
/**
 * Supported value or SQL instance.
 */
type RawValue = Value | Sql;
/**
 * A SQL instance can be nested within each other to build SQL strings.
 */
declare class Sql {
    readonly values: Value[];
    readonly strings: string[];
    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);
}
declare function sql(strings: readonly string[], ...values: readonly RawValue[]): Sql;
declare class MooseClient {
    client: ClickHouseClient;
    constructor(client: ClickHouseClient);
    query(sql: Sql): Promise<_clickhouse_client_web.ResultSet<"JSONEachRow">>;
}
declare const ConsumptionHelpers: {
    column: (value: string) => [string, string];
    table: (value: string) => [string, string];
};
declare function join_queries({ values, separator, prefix, suffix, }: {
    values: readonly RawValue[];
    separator?: string;
    prefix?: string;
    suffix?: string;
}): Sql;

interface AggregationCreateOptions {
    tableCreateOptions: TableCreateOptions;
    materializedViewName: string;
    select: string;
}
interface AggregationDropOptions {
    viewName: string;
    tableName: string;
}
interface MaterializedViewCreateOptions {
    name: string;
    destinationTable: string;
    select: string;
}
interface PopulateTableOptions {
    destinationTable: string;
    select: string;
}
interface TableCreateOptions {
    name: string;
    columns: Record<string, string>;
    engine?: ClickHouseEngines;
    orderBy?: string;
}
interface Blocks {
    setup: string[];
    teardown: string[];
}
declare enum ClickHouseEngines {
    MergeTree = "MergeTree",
    ReplacingMergeTree = "ReplacingMergeTree",
    SummingMergeTree = "SummingMergeTree",
    AggregatingMergeTree = "AggregatingMergeTree",
    CollapsingMergeTree = "CollapsingMergeTree",
    VersionedCollapsingMergeTree = "VersionedCollapsingMergeTree",
    GraphiteMergeTree = "GraphiteMergeTree"
}
/**
 * Drops an aggregation's view & underlying table.
 */
declare function dropAggregation(options: AggregationDropOptions): string[];
/**
 * Drops an existing table if it exists.
 */
declare function dropTable(name: string): string;
/**
 * Drops an existing view if it exists.
 */
declare function dropView(name: string): string;
/**
 * Creates an aggregation which includes a table, materialized view, and initial data load.
 */
declare function createAggregation(options: AggregationCreateOptions): string[];
/**
 * Creates a materialized view.
 */
declare function createMaterializedView(options: MaterializedViewCreateOptions): string;
/**
 * Creates a new table with default MergeTree engine.
 */
declare function createTable(options: TableCreateOptions): string;
/**
 * Populates a table with data.
 */
declare function populateTable(options: PopulateTableOptions): string;

declare const antiCachePath: (path: string) => string;
declare const walkDir: (dir: string, fileExtension: string, fileList: string[]) => string[];
declare const getFileName: (filePath: string) => string;
interface ClientConfig {
    username: string;
    password: string;
    database: string;
    useSSL: string;
    host: string;
    port: string;
}
declare const getClickhouseClient: ({ username, password, database, useSSL, host, port, }: ClientConfig) => _clickhouse_client_web.ClickHouseClient;
type CliLogData = {
    message_type?: "Info" | "Success" | "Error" | "Highlight";
    action: string;
    message: string;
};
declare const cliLog: (log: CliLogData) => void;

interface Aggregation {
    select: string;
    orderBy: string;
}
type Key<T extends string | number | Date> = T;
interface ConsumptionUtil {
    client: MooseClient;
    sql: typeof sql;
}
declare enum IngestionFormat {
    JSON = "JSON",
    JSON_ARRAY = "JSON_ARRAY"
}
type DataModelConfig<T> = Partial<{
    ingestion: {
        format?: IngestionFormat;
    };
    storage: {
        enabled?: boolean;
        order_by_fields?: (keyof T)[];
    };
}>;

export { type Aggregation, type Blocks, ClickHouseEngines, ConsumptionHelpers, type ConsumptionUtil, type DataModelConfig, IngestionFormat, type Key, MooseClient, type RawValue, Sql, type Value, antiCachePath, cliLog, createAggregation, createClickhouseParameter, createMaterializedView, createTable, dropAggregation, dropTable, dropView, getClickhouseClient, getFileName, getValueFromParameter, join_queries, mapToClickHouseType, populateTable, sql, walkDir };
